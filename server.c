
 /*
 * date_proc.c - remote procedures; called by server stub.
 */

/*
 * server.c - Remote System Monitoring Procedures
 * CprE 450/550 Project 1
 */

#include <rpc/rpc.h> /* standard RPC include file */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>  /* Required for sleep() to calculate CPU delta */
#include "date.h"    /* This header is generated by rpcgen -k date.x */   /* this file is generated by rpcgen */

#define MAX_LEN 100

/* * HELPER FUNCTIONS 
 * These read from the Linux /proc virtual filesystem.
 Return the binary date and time.
 */

/* Reads total and free memory from /proc/meminfo */
void get_mem_info(long *total, long *free) {
    FILE *fp = fopen("/proc/meminfo", "r");
    if (fp) {
        /* The kernel provides these as the first two lines of the file */
        fscanf(fp, "MemTotal: %ld kB\nMemFree: %ld kB", total, free);
        fclose(fp);
    }
}

/* Reads the 1-minute load average from /proc/loadavg */
void get_load_info(double *load) {
    FILE *fp = fopen("/proc/loadavg", "r");
    if (fp) {
        fscanf(fp, "%lf", load); 
        fclose(fp);
    }
}

/* * MAIN RPC PROCEDURE
 * This is called by the server stub when a client makes a request.
 */
struct stats * get_stats_1(long *option, struct svc_req *rqstp) {
    static struct stats result;      /* Must be static so memory persists */
    static char time_str_buf[MAX_LEN];
    time_t clock;
    
    /* Variables for CPU delta calculation */
    unsigned long long a[4], b[4], total_a, total_b, idle_a, idle_b;
    FILE *fp;

    /* 1. Get System Time */
    clock = time(0);
    strcpy(time_str_buf, ctime(&clock));
    result.time_str = time_str_buf;

    /* 2. Get Memory and Load Average via Helpers */
    get_mem_info(&result.mem_total, &result.mem_free);
    get_load_info(&result.load_avg);

    /* 3. Get CPU Usage (The Delta Calculation) */
    /* Read first snapshot */
    fp = fopen("/proc/stat", "r");
    if (fp) {
        fscanf(fp, "cpu %llu %llu %llu %llu", &a[0], &a[1], &a[2], &a[3]);
        fclose(fp);
    }
    idle_a = a[3];
    total_a = a[0] + a[1] + a[2] + a[3];

    /* Wait 1 second to measure the change in CPU ticks */
    sleep(1); 

    /* Read second snapshot */
    fp = fopen("/proc/stat", "r");
    if (fp) {
        fscanf(fp, "cpu %llu %llu %llu %llu", &b[0], &b[1], &b[2], &b[3]);
        fclose(fp);
    }
    idle_b = b[3];
    total_b = b[0] + b[1] + b[2] + b[3];

    /* Calculate the percentage: 100 * (TotalTicks - IdleTicks) / TotalTicks */
    if (total_b > total_a) {
        result.cpu_usage = (1.0 - (double)(idle_b - idle_a) / (total_b - total_a)) * 100.0;
    } else {
        result.cpu_usage = 0.0;
    }

    /* Return the pointer to the static result struct */
    return (&result);
}